program
    ::= package-decl
    ( protocol-decl
    | import-decl
    | struct-decl
    | impl-decl
    | enum-decl
    | func-decl
    )*

protocol-decl
    ::= 'protocol' identifier '{'
        (protocol-member (eos protocol-member))?
    '}'

protocol-member
    ::= 'expect' identifier '('
        (protocol-member-parameter (',' protocol-member-parameter)* )?
    ')' type-qualifier eos

protocol-member-parameter
    ::= identifier ':' type-qualifier

package-decl
    ::= 'package' identifier ('.' identifier)* eos

import-decl
    ::= 'import' identifier ('.' identifier)* eos

struct-decl
    ::= 'struct' ('(' struct-attribute+ ')')? identifier ('('
        (struct-parameter (',' struct-parameter)* )?
    ')')? '{'
            (struct-member (eos struct-member)* )?
    '}' | eos

struct-parameter
    ::= identifier ':' struct-parameter-type

struct-parameter-type
    ::= '$type'
    | '$int'
    | '$bool'

struct-attribute
    ::= 'ffi'

struct-member
    ::= identifier ':' type-qualifier


impl-decl
    ::= 'impl' identifier ('for' type-qualifier) '{'
        (impl-member (eos impl-member)* )?
    '}'

impl-member
    ::= impl-member-function

impl-member-function
    ::= 'fn' identifier '('
        (impl-member-parameter (',' impl-member-parameter)* )?
    ')' type-qualifier '{'
        statement*
    '}'

impl-member-parameter
    ::= identifier ':' type-qualifier

func-decl
    ::= 'fn' ('(' func-attribute+ ')')? identifier '('
        (func-parameter (',' func-parameter)* )?
    ')' type-qualifier ':' func-attribute+ '{'
        statement*
    '}' | eos

func-parameter
    ::= identifier ':' type-qualifier

func-attribute
    ::= 'noinline'
    | 'inline'
    | 'ffi'

enum-decl ::= 'enum' ('(' enum-attribute+ ')')? identifier '{'
        (enum-member (',' enum-member)* )?
    '}'

enum-attribute ::= 'ffi'

enum-member ::= identifier ('=' integer-literal)?

statement ::= return-statement
    | for-statement
    | if-statement
    | when-statement
    | break-statement
    | continue-statement
    | expression-statement
    | assign-statement
    | let-statement
    | mut-statement

return-statement
    ::= 'return' expression eos

for-statement
    ::= 'for' for-statement-specifier? '{'
        statement*
    '}'

for-statement-specifier
    ::= boolean-literal
    | for-in-specifier

for-in-specifier
    ::= identifier 'in' expression

if-statement
    ::= 'if' expression '{'
        statement*
    '}' ( 'else' '{'
        statement*
    '}' )?

when-statement
    ::= 'when' expression-list '{'
        (when-clause (eos when-clause)* )?
    '}' ( 'else' '{'
        statement*
    '}' )?

when-clause
    ::= expression-list '=>' expression

break-statement
    ::= 'break' eos

continue-statement
    ::= 'continue' eos

expression-statement
    ::= expression eos

assign-statement
    ::= expression '=' expression eos

let-statement
    ::= 'let' variable-specifier '=' expression eos

mut-statement
    ::= 'mut' variable-specifier '=' expression eos

variable-specifier
    ::= identifier
    | '(' identifier (',' identifier)* ')'

expression-list
    ::= expression+

expression
    ::= or-expression

or-expression
    ::= and-expression ('||' and-expression)*

and-expression
    ::= equality-expression ('&&' equality-expression)*

equality-expression
    ::= comparative-expression (equality-operator comparative-expression)*

comparative-expression
    ::= additive-expression (comparison-operator additive-expression)*

additive-expression
    ::= multiplicative-expression (additive-operator multiplicative-expression)*

multiplicative-expression
    ::= prefix-expression (multiplicative-operator prefix-expression)*

prefix-expression
    ::= prefix-operator constructor-expression

constructor-expression
    ::= type-qualifier '{'
        (constructor-argument (',' constructor-argument)* )?
    '}'

constructor-argument
    ::= identifier ':' literal-expression

call-expression
    ::= primary-expression '('
        (call-argument (',' call-argument)* )?
    ')'

call-argument
    ::= (identifier ':')? primary-expression

primary-expression
    ::= tuple-expression
    | grouping-expression
    | variable-expression
    | literal-expression
    | if-expression
    | when-expression

tuple-expression
    ::= '(' expression ',' (expression (',' expression)* )? ')'

grouping-expression
    ::= '(' expression ')'

variable-expression
    ::= identifier

literal-expression
    ::= integer-literal
    | float-literal
    | boolean-literal
    | char-literal
    | string-literal

if-expression
    ::= 'if' expression '{'
        statement*
    '}' ( 'else' '{'
        statement*
    '}' )?

when-expression
    ::= 'when' expression-list '{'
        (when-clause (eos when-clause)* )?
    '}' ( 'else' '{'
        statement*
    '}' )?

equality-operator
    ::= '=='
    | '!='

comparison-operator
    ::= '<'
    | '>'
    | '<='
    | '>='

additive-operator
    ::= '+'
    | '-'

multiplicative-operator
    ::= '*'
    | '/'
    | '%'

prefix-operator
    ::= '!'
    | '+'
    | '-'
    | '*'
    | '&'

type-qualifier
    ::= tuple-type-qualifier
    | type-type-qualifier
    | reference-type-qualifier
    | template-type-qualifier

// type: (T1, T2, T3)
tuple-type-qualifier
    ::= '('
        type-qualifier (',' type-qualifier)*
    ')'

// type: Vector3
type-type-qualifier
    ::= identifier

// type: Shader&
reference-type-qualifier
    ::= type-type-qualifier '&'

template-type-qualifier
    ::= type-type-qualifier '::<'
        template-type-item (',' template-type-item'')*
    '>'

template-type-item
    ::= template-type-qualifier
    | type-qualifier-literal

type-qualifier-literal
    ::= integer-literal
    | boolean-literal

identifier
    ::= [A-Za-z_][A-Za-z0-9_]+

boolean-literal
    ::= 'true'
    | 'false'

integer-literal
    ::= numeral-literal
    | hexadecimal-literal

float-literal
    ::= numeral-literal '.' numeral-literal

numeral-literal
    ::= [0-9]+

hexadecimal-literal
    ::= '0x' [A-Fa-f0-9]+

string-literal
    ::= '"' ( '\\' [\\"rtn] | [.] )*? '"'

char-literal
    ::= "'" [A-Za-z] | (
        '\\u' hexadecimal-literal hexadecimal-literal
              hexadecimal-literal hexadecimal-literal
    ) "'"

single-line-comment
    ::= '//' ~[\r\n]*

eos
    ::= ( EOF
    | '\n'
    | ';'
    )+